#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                      (C) 2006-2010  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#

from pyre.applications.Script import Script

class App(Script):

    class Inventory(Script.Inventory):

        import pyre.inventory
        
        inputfilename = pyre.inventory.str('input')


    def __init__(self, name='mcvine-convert-mcstas-instrument'):
        super(App, self).__init__(name)
        return

    
    def main(self):
        input = self.inventory.inputfilename
        text = open(input).read()
        from mcstas2.utils.parsers.McStasInstrumentParser import McStasInstrumentParser
        parser = McStasInstrumentParser()
        instrument = parser.parse(text)
        
        fname = os.path.basename(input)
        instrname, ext = os.path.splitext(fname)

        instrument.name = instrname

        try:
            self._render(instrument)
        except:
            import traceback
            traceback.print_exc()
            print
            self._onError()
        return

    
    def _onError(self):
        print '*'*70
        print 'This conversion script is still experimental'
        print 'Please check'
        print ' * If component parameters (including position and rotation parameters)'
        print '   contain references to c variables.'
        return


    def _render(self, instrument):
        self._createInstrumentScript(instrument)
        self._createPml(instrument)
        return


    def _createInstrumentScript(self, instrument):
        complist = ','.join([c.name for c in instrument.components])
        d = {
            'name': instrument.name,
            'components': complist,
            }
        cmd = 'mcvine-create-instrument-simulation-application -name=%(name)s -components=%(components)s' % d
        cmd += '> /dev/null'
        if os.system(cmd):
            raise RuntimeError, "%s failed"  % cmd
        print '* generated mcvine app "%s"' % instrument.name


    def _createPml(self, instrument):
        out = '%s.pml' % instrument.name
        if os.path.exists(out):
            os.remove(out)
        
        text = PmlRenderer().render(instrument)
        text = '\n'.join(text)
        open(out, 'w').write(text)
        print '* generated configuration "%s"' % out
        return

    pass



class PmlRenderer(object):


    def render(self, instrument):
        self._reps = []
        self._indlevel = 0
        self._indstr = '  '
        self._write('<?xml version="1.0"?>')
        self._write('<inventory>')
        self._indent()
        self.onInstrument(instrument)
        self._outdent()
        self._write('</inventory>')
        return self._reps
    

    def onInstrument(self, instrument):
        self._write('<component name="%s">' % instrument.name)
        self._indent()

        self._property('sequence', ','.join([c.name for c in instrument.components]))
        for c in instrument.components:
            self._property(c.name, c.type)
            continue

        self.onGeometer(instrument)
        self._write('')

        self._property('multiple-scattering', 'off')
        
        self._property('ncount', "1e6")
        self._property('buffer_size', 100000)
        
        self._property('output-dir', 'out')
        self._property('overwrite-datafiles', 'off')
        self._write('')

        for c in instrument.components:
            self.onComponent(c)
            self._write('')
            continue
        
        self._outdent()
        self._write('</component>')
        return


    def onGeometer(self, instrument):
        self._write('<component name="geometer">')
        self._indent()
        for c in instrument.components:
            k = c.name
            v = self._geometerEntry(c.position, c.orientation)
            self._property(k,v)
            continue
        self._outdent()
        self._write('</component>')
        return


    def onComponent(self, component):
        self._write('<component name="%s">' % component.name)
        self._indent()
        for k,v in component.parameters.iteritems():
            self._property(k,v)
            continue
        self._outdent()
        self._write('</component>')
        return


    def _geometerEntry(self, position, orientation):
        position = self._coord(position)
        orientation = self._coord(orientation)
        return ','.join((position, orientation))


    def _coord(self, coord):
        v, relation, to = coord
        if relation.lower() == 'absolute' or \
                relation.lower() == 'relation' and to.lower() == 'absolute':
            return str(v)
        else:
            assert relation.lower() == 'relative'
            return 'relative(%s, to="%s")' % (v, to)


    def _property(self, k, v):
        t = '<property name="%s">%s</property>' % (k,v)
        self._write(t)
        return


    def _write(self, text):
        t = self._indlevel * self._indstr + text
        self._reps.append(t)
        return


    def _indent(self): self._indlevel += 1
    def _outdent(self): self._indlevel -= 1



import os


def main(): 
    app = App()
    app.run()
    return


if __name__ == '__main__': main()


# version
__id__ = "$Id: mcvine-list-components 601 2010-10-03 19:55:29Z linjiao $"

# End of file 
