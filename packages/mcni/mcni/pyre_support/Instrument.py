#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                        (C) 2007  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#



from MpiApplication import Application as base
from ParallelComponent import ParallelComponent

class Instrument( base, ParallelComponent ):

    class Inventory( base.Inventory ):

        import pyre.inventory
        
        #properties
        ncount = pyre.inventory.float('ncount', default = 10000)
        ncount.meta['tip'] = 'number of total neutrons generated by source'
        
        outputdir = pyre.inventory.str('output-dir', default = 'out')
        outputdir.meta['tip'] = 'output directory'

        overwrite_datafiles = pyre.inventory.bool(
            'overwrite-datafiles',  default = False)
        overwrite_datafiles.meta['tip'] = 'overwrite data files?'
        
        buffer_size = pyre.inventory.int  ('buffer_size', default = 1000)
        buffer_size.meta['tip']= 'size of neutron buffer. This is for optimizing the preformance of the simulation. When it is too large, it will occupy too much memory. When it is too small, the simulation will be slow. If you are not sure, please just leave it unset so that the default value will be used.'

        from List import List
        sequence = List( 'sequence', default = '' )
        sequence.meta['tip'] = 'sequence of neutron components in this instrument'

        multiple_scattering = pyre.inventory.bool('multiple-scattering', default=False)
        multiple_scattering.meta['tip'] = 'if true, enable multiple scattering'

        #facilities

        #geometer. this is a place holder. should derive from Geometer
        #to create a new Geometer for the specific instrument.
        from Geometer import Geometer
        geometer = pyre.inventory.facility(
            'geometer', default = Geometer() )
        geometer.meta['tip'] = 'geometer of instrument'

        pass # end of Inventory


    def __init__(self, name):
        base.__init__(self, name)
        self._warning = journal.warning( name )
        return


    def help(self):
        print '------------------------------------------------------------'
        print '* Instrument simulation application %r' % self.name
        print '------------------------------------------------------------'
        print '* Sequence of components:'
        print '  ', self._componentListStr()
        print '------------------------------------------------------------'
        print '* Command:'
        print self._cmdlineDemoStr()
        print '------------------------------------------------------------'
        return


    def main(self, *args, **kwds):
        neutron_components = self.neutron_components
        for comp in neutron_components:
            if comp not in self.sequence:  
                self._warning.log(
                    'component %s was not included in component sequence %s' % (
                    comp, self.sequence )
                    )
                pass
            continue

        for name in self.sequence:
            if name not in neutron_components:
                raise RuntimeError , "Neutron component %s specified in sequence %s does not " \
                      "correspond to any known simulation components: %s" % (
                    name, self.sequence, neutron_components )
            continue

        import mcni
        components = [ neutron_components[ name ] for name in self.sequence ]
        instrument = mcni.instrument( components )

        geometer = self.geometer

        multiple_scattering = self.inventory.multiple_scattering
        n = int(self.ncount / self.buffer_size)
        assert n>0
        for i in range(n):
            neutrons = mcni.neutron_buffer( self.buffer_size )
            mcni.simulate( instrument, geometer, neutrons, 
                           multiple_scattering=multiple_scattering)
            continue

        return


    def _defaults(self):
        base._defaults(self)
        self.inventory.geometer = _build_geometer( self )
        return


    def _setup_ouputdir(self):
        outputdir = self.outputdir
        if not self.overwrite_datafiles and os.path.exists( outputdir ):
            print "output directory %r exists. If you want to overwrite the output "\
                  "directory, please specify option --overwrite-datafiles." % outputdir

        if not os.path.exists( outputdir ):
            os.makedirs( outputdir )
            pass

        for component in self.neutron_components.itervalues():
            component.setOutputDir( outputdir )
            if self.parallel:
                # need to let the master node component know the "master" outputdir
                if self.mpiRank == 0:
                    component._master_outputdir = self.inventory.outputdir
            component.overwrite_datafiles = self.overwrite_datafiles
            continue
        
        return
    
    
    def _configure(self):
        base._configure(self)
        self.geometer = self.inventory.geometer
        self.overwrite_datafiles = self.inventory.overwrite_datafiles

        self.outputdir = self.inventory.outputdir
        if self.parallel:
            ext = self._outputdir_mpiext()
            self.outputdir = '%s-%s' % (self.outputdir, ext)
            
        self.sequence = self.inventory.sequence
        self.ncount = self.inventory.ncount
        if self.parallel:
            # every node only need to run a portion of the total counts
            partitions = getPartitions(self.ncount, self.mpiSize)
            self.ncount = partitions[self.mpiRank]

        self.buffer_size = self.inventory.buffer_size

        neutron_components = {}
        for name in self.inventory.facilityNames():
            comp = self.inventory.getTraitValue( name )
            if self._showHelpOnly:
                comp._showHelpOnly = True
            if isinstance(comp, McniComponent):
                neutron_components[ name ] = comp
                pass
            continue

        self.neutron_components = neutron_components
        
        if not self._showHelpOnly: self._setup_ouputdir()
        return


    def _outputdir_mpiext(self):
        mode = self.inventory.mode
        rank = self.mpiRank
        return '%s-%s' % (mode, rank)


    def _componentListStr(self):
        comps = self.neutron_components
        l = []
        for name in self.inventory.sequence:
            comp = comps[name]
            if hasattr(comp, 'uri'): uri = comp.uri
            else: uri = comp.name
            l.append( (name, uri) )
            continue
        return ' --> '.join(['[%s(%s)]' % (n, u) for n,u in l])
        

    def _cmdlineDemoStr(self):
        s = ' $ %s ' % self.name
        opts = []
        skipappprops=['name', 'typos', 'journal', 'geometer', 'sequence', 'weaver']+\
            self.inventory.sequence

        from _invutils import getComponentPropertyNameTipPairs
        appopts = getComponentPropertyNameTipPairs(self, skipappprops)
        opts += [(n, '<%s>'%tip) for n, tip in appopts]
        for comp in self.inventory.sequence:
            opts.append( ('geometer.%s' % comp, '<position>,<orientation>') )
            continue
        for name in self.inventory.sequence:
            opts.append( (name, '<component type>') )
            continue
        components = self.neutron_components
        for name in self.inventory.sequence:
            comp = components[name]
            pairs = getComponentPropertyNameTipPairs(comp)
            pairs = [ ('%s.%s' % (name, n), '<%s>' % tip) for n, tip in pairs]
            opts += pairs
            continue
        l = [s] + ['  --%s=%s' % (k,v) for k, v in opts]
        return ' \\\n'.join(l) 


    # overwrite processCommandline so that we know
    # user is requesting for help and avoid unecessary
    # initialization and finalization of components
    def processCommandline(self, registry):
        ret = super(Instrument, self).processCommandline(registry)
        help = ret[0]
        if help: self._showHelpOnly = True
        return ret
    

    pass # end of Instrument



def _build_geometer( instrument ):
    
    #find all components
    Inventory = instrument.Inventory
    componentnames = dir(Inventory)

    from NeutronComponentFacility import NeutronComponentFacility
    componentnames = filter(
        lambda name: isinstance(
            getattr(Inventory, name), NeutronComponentFacility ),
        componentnames )
    
    #build the Geometer component
    declarations = [
        8*' ' + '%s = Register("%s")' % (name, name) for name in componentnames ]
    declarations = '\n'.join( declarations )
    
    from Geometer import Geometer as base, Register
    code = '''
class Geometer1(base):
    class Inventory(base.Inventory):
%s
''' % declarations
    
    exec code in locals()
    
    return Geometer1()
    

def getPartitions(N, n):
    return list(getPartitionIterator(N,n))

def getPartitionIterator( N, n ):
    '''create an iterator of n partitions where the sum of all partions is N
    All partitions should be about the same size.
    '''
    from math import ceil
    residual = N
    nbins = n
    while residual:
        if nbins > 1:
            size = int( ceil(residual*1./nbins) )
        else:
            size = residual
        yield size
        residual -= size
        nbins -= 1
    return 


from mcni.AbstractComponent import AbstractComponent as McniComponent
import os, journal


# version
__id__ = "$Id$"

# End of file 
