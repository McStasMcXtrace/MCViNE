#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                   Jiao Lin
#                      California Institute of Technology
#                        (C) 2007  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#



from MpiApplication import Application as base
from ParallelComponent import ParallelComponent

class Instrument( base, ParallelComponent ):

    class Inventory( base.Inventory ):

        import pyre.inventory
        
        #properties
        ncount = pyre.inventory.float('ncount', default = 10000)
        ncount.meta['tip'] = 'number of total neutrons generated by source'
        
        outputdir = pyre.inventory.str('output-dir', default = 'out')
        outputdir.meta['tip'] = 'output directory'

        overwrite_datafiles = pyre.inventory.bool(
            'overwrite-datafiles',  default = False)
        overwrite_datafiles.meta['tip'] = 'overwrite data files?'
        
        buffer_size = pyre.inventory.int  ('buffer_size', default = 1000)
        buffer_size.meta['tip']= 'size of neutron buffer'

        from List import List
        sequence = List( 'sequence', default = '' )
        sequence.meta['tip'] = 'sequence of neutron components in this instrument'

        #facilities

        #geometer. this is a place holder. should derive from Geometer
        #to create a new Geometer for the specific instrument.
        from Geometer import Geometer
        geometer = pyre.inventory.facility(
            'geometer', default = Geometer() )
        geometer.meta['tip'] = 'geometer of instrument'

        pass # end of Inventory


    def __init__(self, name):
        base.__init__(self, name)
        self._warning = journal.warning( name )
        return


    def main(self, *args, **kwds):
        neutron_components = self.neutron_components
        for comp in neutron_components:
            if comp not in self.sequence:  
                self._warning.log(
                    'component %s was not included in component sequence %s' % (
                    comp, self.sequence )
                    )
                pass
            continue

        for name in self.sequence:
            if name not in neutron_components:
                raise RuntimeError , "Neutron component %s specified in sequence %s does not " \
                      "correspond to any known simulation components: %s" % (
                    name, self.sequence, neutron_components )
            continue

        import mcni
        components = [ neutron_components[ name ] for name in self.sequence ]
        instrument = mcni.instrument( components )

        geometer = self.geometer

        n = int(self.ncount / self.buffer_size)
        assert n>0
        for i in range(n):
            neutrons = mcni.neutron_buffer( self.buffer_size )
            mcni.simulate( instrument, geometer, neutrons )
            continue

        return


    def _defaults(self):
        base._defaults(self)
        self.inventory.geometer = _build_geometer( self )
        return


    def _setup_ouputdir(self):
        outputdir = self.outputdir
        if not self.overwrite_datafiles and os.path.exists( outputdir ):
            print "output directory %r exists. If you want to overwrite the output "\
                  "directory, please specify option --overwrite-datafiles." % outputdir

        if not os.path.exists( outputdir ):
            os.makedirs( outputdir )
            pass

        for component in self.neutron_components.itervalues():
            component.setOutputDir( outputdir )
            if self.parallel:
                # need to let the master node component know the "master" outputdir
                if self.mpiRank == 0:
                    component._master_outputdir = self.inventory.outputdir
            component.overwrite_datafiles = self.overwrite_datafiles
            continue
        
        return
    
    
    def _configure(self):
        base._configure(self)
        self.geometer = self.inventory.geometer
        self.overwrite_datafiles = self.inventory.overwrite_datafiles

        self.outputdir = self.inventory.outputdir
        if self.parallel:
            ext = self._outputdir_mpiext()
            self.outputdir = '%s-%s' % (self.outputdir, ext)
            
        self.sequence = self.inventory.sequence
        self.ncount = self.inventory.ncount
        if self.parallel:
            # every node only need to run a portion of the total counts
            partitions = getPartitions(self.ncount, self.mpiSize)
            self.ncount = partitions[self.mpiRank]

        self.buffer_size = self.inventory.buffer_size

        neutron_components = {}
        for name in self.inventory.facilityNames():
            comp = self.inventory.getTraitValue( name )
            if isinstance(comp, McniComponent):
                neutron_components[ name ] = comp
                pass
            continue

        self.neutron_components = neutron_components
        
        if not self._showHelpOnly: self._setup_ouputdir()
        return


    def _outputdir_mpiext(self):
        mode = self.inventory.mode
        rank = self.mpiRank
        return '%s-%s' % (mode, rank)
        


    pass # end of Instrument



def _build_geometer( instrument ):
    
    #find all components
    Inventory = instrument.Inventory
    componentnames = dir(Inventory)

    from NeutronComponentFacility import NeutronComponentFacility
    componentnames = filter(
        lambda name: isinstance(
            getattr(Inventory, name), NeutronComponentFacility ),
        componentnames )
    
    #build the Geometer component
    declarations = [
        8*' ' + '%s = Register("%s")' % (name, name) for name in componentnames ]
    declarations = '\n'.join( declarations )
    
    from Geometer import Geometer as base, Register
    code = '''
class Geometer1(base):
    class Inventory(base.Inventory):
%s
''' % declarations
    
    exec code in locals()
    
    return Geometer1()
    

def getPartitions(N, n):
    return list(getPartitionIterator(N,n))

def getPartitionIterator( N, n ):
    '''create an iterator of n partitions where the sum of all partions is N
    All partitions should be about the same size.
    '''
    from math import ceil
    residual = N
    nbins = n
    while residual:
        if nbins > 1:
            size = int( ceil(residual*1./nbins) )
        else:
            size = residual
        yield size
        residual -= size
        nbins -= 1
    return 


from mcni.AbstractComponent import AbstractComponent as McniComponent
import os, journal


# version
__id__ = "$Id$"

# End of file 
